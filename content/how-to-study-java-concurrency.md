---
title: 怎么学好Java并发编程?
description: Java并发编程，是一项学习难度很高的技术。要想学好它，需要涉猎多方面的知识：1.操作系统知识，例如,线程的"时间切片",cpu指令的原子性,cpu缓存；2.jvm知识，如"synchronized","volidate"等的原理，"编译优化"带来的有序性问题等;3.java自身的api，如java并发包。经过多年的编程和实践，我认为想学好一门技术，应该从两方面着手：广度和深度。所谓广度，是应该建立对知识认知的全景图，这样可以避免知识的遗忘，也可避免过于追求细节而无法自拔，误入歧途；所谓深度，在广度基础上，建立起一种理论:知识怎么来的?解决了什么问题?怎么使用更好?下面回到Java并发编程的话题上，聊一聊怎么学好它?
---

# 怎么学好Java并发编程?

Java并发编程，是一项学习难度很高的技术。要想学好它，需要涉猎多方面的知识：1.操作系统知识，例如,线程的"时间切片",cpu指令的原子性,cpu缓存；2.jvm知识，如"synchronized","volidate"等的原理，"编译优化"带来的有序性问题等;3.java自身的api，如java并发包。经过多年的编程和实践，我认为想学好一门技术，应该从两方面着手：广度和深度。所谓广度，是应该建立对知识认知的全景图，这样可以避免知识的遗忘，也可避免过于追求细节而无法自拔，误入歧途；所谓深度，在广度基础上，建立起一种理论:知识怎么来的?解决了什么问题?怎么使用更好?下面回到Java并发编程的话题上，聊一聊怎么学好它?



## 广度

我对Java并发编程的理解，可以抽象为三个问题:分工，同步，互斥。所以我从这三个方面来说说，我对java并发编程理解的大致轮廓。



### 分工

所谓分工，可以理解为将任务进行拆分，安排不同的线程执行。例如,项目经理将一个大的需求拆分一个个小的需求，分别交给后台，前端，移动端,UI，测试等五个人员并行配合完成。



分工，就是要求我们站在任务的视角来解决问题，提高并发程序的性能。Java中的一些工具类，本质上就是一种分工方法：比如并行任务，可以通过"线程池+Future"来解决;任务之间有聚合关系，AND聚合还是OR聚合,通过CompletableFuture解决,Fork/Join;批量的并行任务，可以通过CompletionService解决;除此之外，并发编程的一些设计模式也是和分工相关的，例如生产者-消费者设计模式是教你如何分工的。



### 同步

分好工之后，就是具体执行，不同任务执行的过程中，可能需要进行相互沟通协作，这就是同步。例如，后端开发好接口需要给出开发文档到前端和移动端，前端和移动端针对接口可能出现的而问题反馈给后端。

同步，在并发编程领域，指的就是不同线程间的通信。例如，用Future我们可以取得子线程执行的结果，在主线程种执行get()，主线程会等待，当拿到结果，主线程会继续执行。Future工具类可以帮助我们解决线程同步问题，除此之外，还有CountDownLatch,CyclicBarrier等等。

同步的核心问题可以描述为:当某个条件不满足时，线程进入等待;当某个条件满足时，线程进入唤醒执行阶段。例如，生产者-消费者模型，当队列不满时，生产者线程被唤醒执行,反之则等待;当队列不为空时候，消费者线程被唤醒执行，反之则等待。

解决同步问题的核心技术是管程，管程是一种解决并发问题的通用模型。我们需要理解管程模型，然后了解Java SDK并发包提供的线程同步的工具类的使用场景，用好它们，可以很好的提高我们的工作效率。



### 互斥

互斥，指的是同一时刻，只允许一个线程访问共享变量。分工，同步可以提高并发程序的性能；互斥，是为了保证并发程序的执行的正确性。



互斥是解决线程安全问题的核心技术。并发程序里，多个线程同时访问同一个共享变量的时候，结果是不确定的。带来这种不确定性的原因，一般是可见性问题，有序性问题，原子性问题引起的。为了解决这三个问题，java语言引入了内存模型，内存模型提供了一系列规则，可以避免可见性，有序性问题问题，但是没法解决原子性问题。所以，解决线程安全问题的核心还是互斥。



实现互斥的技术，包括"synchronized"关键字，SDK里的Lock相关工具类。锁在提供了安全的同时，也会带来性能问题。为了解决安全性问题，又要尽量提高性能。我们需要分场景优化，例如使用ReadWriteLock，StampedLock可以优化读多写少的场景下的性能；还比如可以使用无锁的数据结构，例如Java并发包种的原子类就是基于无锁的技术实现的。



在解决并发程序安全问题方面，除了锁技术，无锁技术外，还可以从共享变量着手。不共享变量或变量只允许读，也可以保证线程安全。例如ThreadLocal工具类和final关键字，还有一种Copy-on-write的模式等等。



综上所述，在知识的广度方面的积累，需要我们将所学的知识体系化，构造一个脉络清晰的知识网络。



## 深度

我们在所学的知识形成体系后，还要对某方面的问题进行深入理解，找到本质。我们应该去深究概念和结论的由来，它们是用来解决什么问题的。我们最终应该形成一种理论，以此为基础去解决问题，将会更加得心应手。例如，synronized关键字为什么能够使得方法在不同线程间互斥？volidate关键字为了能让共享变量在不同线程间可见？



## 总结

当初我们学习java并发编程的时候，还是只会创建线程，给方法加锁，也试图想去使用java并发包，但是最终还是觉得synchronized关键字比较简单，最终放弃了。那时候遇到并发问题，会借助网上的技术文章，最终把问题解决了，当时感觉也理解了。但是过了不久，还是忘记了。遇到实际的并发问题，不知道从何处下手，怎么写代码最合适。出现上述现象，都是因为我们所学的知识，没有成体系。要让我们的知识成体系，一定要挖掘知识的脉络和本质，并发编程，我觉得主要使围绕分工，同步，互斥等三个方面展开的，这样可以迅速帮我们建立并发问题的解题思路，梳理并发编程的知识，加深认识。探索知识的理论本质，是一件一举多得的事情。因为一项优秀的理论在多个语言种都有体现，不同领域都有应用。











